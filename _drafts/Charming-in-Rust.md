---
layout: post
title: Charming in Rust
---
Today all charms in the juju charm store are Python except for one. The gluster charm I wrote is the first compiled charm to be accepted into the charm store. Why write a charm in Rust? The story starts a long time ago. 

I was a new employee at canonical. I learned about juju which is a modeling tool that enables applications to talk to one another. This becomes a powerful concept when applied to big software like open stack. Openstack has many components and many of them need to interact. Juju makes this easy. In learning about juju I found out that charms (a juju application) could be written in any language. I thought this was an amazing idea. I had recently worked at Facebook where thrift was used. This allowed teams to write in nearly any language they wanted. Being the storage team lead I looked at the state of the juju storage charms. Ceph, Gluster, Swift and others. Ceph and Swift were written in Python. Gluster at the time was written in bash. The charm needed work and I knew that fixing it up would enable a whole new market to open up. 

Greenfield programming can be really exciting. So many possibilities! I started writing the new charm in Python. Gluster is unfortunate to program against because there's either the undocumented XML mode or CLI screen scraping. No rest API here! I began writing classes to model the major concepts in gluster. I then stopped myself and did some thinking. I had previously worked with a gluster management service written in Python. While it was powerful it also had a major flaw. This critical software had bugs that lurked but were difficult to track down. The code had been through code review, unit testing, integration testing and finally canary testing. If you're not familiar with using canaries with services it involves picking a few machines and upgrading them to the new code. They're observed for awhile and then the patch is deemed safe. The problem with all this is that some code paths might only be exercised very rarely. When that happens bugs can show their ugly heads. Humans make bad compilers. When I review code I'm looking for correct logic not necessarily correct type usage throughout the program. That's a boring job that was solved a long time ago with the advent of compilers. After years of fighting these bugs the team I was on started gravitated towards a rewrite of the gluster management service into a compiled language. All this experience started to come surging back into my thoughts as I wrote this new gluster charm. Did I want to commit myself to the same headaches as before? Collectively the juju ecosystem team had decided that we were a Python shop. My thinking was dangerous because it would go against protocol. 

After giving Go a try and playing with Rust I started to think about my experience at Nebula. I built with the help of Shevek a Ceph manager in Java. I must say it was some of the best code I've created. Java while significantly different than years ago was still a non starter with many infrastructure folks. Had I decided to write the charm in Java I might as well start looking for another job. The upside would've been maximum compatibility. Yes I'm aware of the joke: compile once, debug everywhere. I decided to give Rust a real shot. It had a lot going for it. A budding ecosystem of libraries. A thriving IRC community. A powerful compiler with easy to understand error messages. Lack of garbage collection. All dependencies are built into the binary. Speed and memory safety were just bonuses. It also inferred most of the types so the code was compact. Lastly Rust makes the right way to write code the path of least resistance. For instance the compiler will warn and can be set to error if a returned Result is not checked. Many other languages will let you simply ignore that. Think of all the bugs that have surfaced in C from not checking return codes. 

Juju actually made writing a charm in Rust easy. All the interaction with juju happens through bash commands. With a few helper libraries I wrote with a coworker it became easy. Rusts' compiler is very strict and it worked to my advantage. Rather than create more burden on my team to review large chunks of code I had the compiler work out many types of errors. Their job then became to review the logic. To evaluate the approach and maintainability. In short to do what humans are good at! The other upside was I could accept patches to my charm without fear. The compiler is ensuring that the new code fits with the existing without anything breaking. Sure people can commit patches with bad logic but that will always happen. With Python a patch might change code that gets called by a far flung function that now breaks because of a type mismatch. This happens often enough in the Ceph charm that it's rather annoying at best and terrible at worst. Shipping code that may blow up in production because of a type mismatch keeps me up at night. I think in the beginning Python feels very fast. No types getting in the way. Magical type transformation where needed. No waiting on a compiler. Runs on nearly any architecture these days. After shipping code I'm constantly finding myself endlessly writing tests to check all the possible mutations of how the code will be exercised. An extremely slow fuzzer if you will. For instance a bug recently surfaced with some upgrade code that I wrote that had been looked at by many people and run in production for months. Eventually it was discerned that I had a [type mismatch]() that my unit tests were not surfacing.  By instead using a strongly typed statically compiled language I was building on top of a solid base. 

At a previous openstack summit Vish who is a friend of mine stood up in front of the audience and said he thought that building such a large project in Python was a mistake. I'm paraphrasing what he said. 

## Code

The rust charm operates exactly the same as a Python charm. I'm the main function there is a match against the name the binary was called with. This then calls a function to fulfill the request: 
```

```
Logging and juju status updates are handled by a macro. This was done for ergonomic reasons. Calling the macro involves much less typing and looks cleaner:
```

```

## Helper libraries
The gluster charm makes use of several helper libraries. Some of which I wrote. 

## Portability
Juju charms are ideally architecture agnostic. This has been one of the bigger challenges with writing rust. x86_64, i686, powerpc are the easiest to build for. IBM z series and arm have proven difficult. I haven't solved this yet but I'm thinking of having a bash script that detects the correct architecture or building the charm into a snapcraft snap and having that so the architecture detection. 

## Continuous integration
Rust has the same flow as Python. Unit test your functions as much as possible. Integration test to flush out compatibility bugs. Ensure that tests are run in each patch to keep master working. 